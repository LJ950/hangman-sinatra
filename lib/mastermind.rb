class Mastermind
	def initialize
		puts "Enter player 1 name"
		player_name = gets.chomp
		@board = Board.new
		@player = Player.new("player_name")
		set_player_role
		@turn = -1
	end

	def set_player_role #makes new variables assigned to human or computer depending on player choice
		puts "Do you want to be the code (m)aker or the code (b)reaker?"
		breaker_or_maker = gets.chomp.downcase
		if breaker_or_maker == "m"
			@breaker = Computer.new(breaker_or_maker)# maker or breaker argument changes initialize options in the computer class
			@maker = @player
		elsif breaker_or_maker == "b"
			@breaker = @player
			@maker = Computer.new(breaker_or_maker)
		end
	end			

	def play #controls game flow
		@turn += 1 #counts turns which is used to determine if the player needs to set a code on their first go and by the show_board method to determine which row to fill in
		if @player == @breaker #goes through the player as the breaker process
			puts "Enter 4 letters as your code guess..."
			puts "b = black, w = white, r = red, y = yellow, g = green, p = pink"
			code_guess = gets.chomp.upcase.split("")
			if valid_move?(code_guess)
				@board.show_feedback(code_guess,@maker.code,@turn)
			else
				puts "Invalid Move! Please enter 4 letters from choice above."
				@turn -= 1 #turn is taken down by one as the play method is called again for the correct choice
			end

		elsif @player == @maker #for clarity
			if @turn == 0 #on first turn player must choose their code
				@player.set_player_code
			end
			if valid_move?(@maker.code) #don't need to check this as it is generated by the computer but useful if game is refactored for 2 human players
				code_guess = @breaker.gen_code(@board,@maker.code)
				puts "Computer guesses #{code_guess.join(" ")}"
				@board.show_feedback(code_guess,@maker.code,@turn)
			end
		else #if set_player_role has failed this will be invoked
			puts "Error" # "m" or "b" required
			set_player_role
		end
		end_game #check to see if there is a winner. Exit clauses are in this method.
		play
	end

	def valid_move?(code) #validates code inputs. either code guess or set code can be supplied as arguments
		if code.length == 4
			code.all? { |el| /[bwrygp]/.match(el.downcase) }
		end
	end

	def end_game #checks if either player has won and exits if they have
		if @board.fb_ary.all? {|x| x == "correct"}
			puts "#{@breaker.name} Wins!"
			@board.reveal_code(@maker)
			exit
		end
		if @turn == 11
			puts "#{@maker.name} Wins!"
			@board.reveal_code(@maker)
			exit
		end
	end
end

class Board
	attr_reader :fb_ary
	def initialize
		@code_grid = Array.new(12) {Array.new(4,"-")}
		@feedback_grid = Array.new(12) {Array.new(4,"-")}
		@fb_ary = []
	end

	def show_feedback(code_guess, code, turn) #displays the feedback generated in the feedback method. code_guess and code are required for the feedback.
		feedback(code_guess,code)

		i = 0
		while i < 4
			@code_grid[turn][i] = code_guess[i] #turn determines the line on the grid to be completed
			@feedback_grid[turn][i] = @fb_ary[i]
			i += 1
		end
		@code_grid.each_with_index do |arr,j|
	  	puts " | " + arr.each { |square| square }.join(" | ") + " | |" + @feedback_grid[j].join("|") + "|"
	  end
	end

	def reveal_code(role) #additional method to display the code when the game is over. Call after the show_board method. Role tells whether to show the breakers or the makers code.
		puts " -----------------"
		puts " | " + role.code.join(" | ") + " |"
		puts " -----------------"
		@code_grid.each do |arr|
	  puts " | " + arr.each { |square| square }.join(" | ") + " |"
		end
		puts " -----------------"
	end

	def feedback(code_guess, code) #generates feedback from the code_guess and the code given when a code is entered.
		c_code = code.dup #have to be duplicatd as the it uses destructive methods (delete_at) and the original code is required for the show_board display
		c_g = code_guess.dup
		fb_ary = Array.new(4)
		i = 0
		while i < 4 do #checks for exact matches and makes matching elements from each side nil so they are not matched again
			if c_code[i] == c_g[i]
				fb_ary << "correct"
				c_code[i] = nil
				c_g[i] = nil #set to nil rather that delete as delete would change the order 
			end
			i += 1
		end

		c_code -= [nil] #removes nils in arrays
		c_g -= [nil] #could also use compact!

		(c_code.length).times do 
			j = 0
			while j < c_code.length #checks for exact matches on a given iteration and deletes matches so they are not matched again
				if c_code[j] == c_g[j]
					fb_ary << "colour match"
					c_code.delete_at(j)
					c_g.delete_at(j)
				end
				j += 1
			end
			c_g << c_g.shift #removes 1st element and adds it as last element on c_g array to facilitate a rotation to check all combinations
		end
		while fb_ary.length > 4
			fb_ary.shift #removes empty(nil) elements at the start of the array caused by checking 6 letters in 1 array vs 4 in the other (nil matches nil)
		end
		@fb_ary = fb_ary.shuffle #shuffles array so feedback cannot be linked to the order of code guesses
	end
end

class Player
	attr_accessor :name
	attr_reader :code
	def initialize(name)
		@name = name
	end

	def set_player_code
		puts "Enter your 4 letter code..."
		puts "b = black, w = white, r = red, y = yellow, g = green, p = pink"
		@code = gets.chomp.upcase.split(//)
	end
end

class Computer
	attr_reader :code, :name
	def initialize(role) #role is single letter string to determing whether the player is the maker or breaker
		@name = "Deep Thought"
		@save_code = []
		if role == "b" #if player is breaker this tells the computer to generate a code to break
			@code = gen_code
		end
	end

	def gen_code(board=nil, maker_code=[]) #board contains the instance of the board class created when the game is initialized
		code = []

		maker_code.each do |el| #adds matching letters from the last code created which are found in the code chosen by the player
			if @save_code.join.match(el)
				code << el
			end
		end
		(4-code.length).times do #generates numbers 1 to 6 randomly to make array contain 4 elements
			code << rand(1..6)
		end
			
		@save_code = code.shuffle! #saves the code in an instance variable to help with the next 'guess' randomizes the computer guesses so it doesn't always win!

		code.map! do |n| #maps the generated numbers to letters
			case n
			when 1
				n = "B"
			when 2
				n = "W"
			when 3
				n = "R"
			when 4
				n = "Y"
			when 5
				n = "G"
			when 6
				n = "P"
			end
		end
	end
end

Mastermind.new.play